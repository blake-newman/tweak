// Generated by CoffeeScript 1.10.0

/*
  Tweak.js 1.0.0
  (c) 2014 Blake Newman.
  TweakJS may be freely distributed under the MIT license.
  For all details and documentation:
  http://tweakjs.com

  NOTE: This version of Tweak.js is a sub version created for Ignition as a stable code base for current projects.
  It is hosted on bitbucket.org under eframe.

  Tweak.js can be accessed globaly by tweak or Tweak. If using in node or a CommonJs then Tweak.js is not global.

  @note Assign ($, jQuery, Zepto...) to Tweak.$ for internal use. By default it will try to auto detect a value to use.
  This value can be overriden at any point.

  @note Assign module loader's require method to Tweak.require. By default it will try to auto detect a value to use;
  depending on the enviroment and module loader used you may need to overwrite this value.

  @note Assign true to Tweak.strict when you wish all components to require a related config module. By default this
  module does not need to exist however  it is recommended as it allows powerful auto generation of components and deep
  extensions.

  Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
  is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
  understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
  community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
 */

(function() {
  var Tweak,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Tweak = (function() {
    var affixReg, root, rootReg, slashReg, splitPathReg, upReg;

    root = null;


    /*
      This constructs Tweak with default properties. Tweak is automatically assigned to Tweak, tweak and module.exports.
     */

    function Tweak(_root, require, $1) {
      this.require = require;
      this.$ = $1;
      root = _root;
      this.pTweak = root.Tweak;
    }


    /*
      To extend an object with JS use Tweak.extends().
      @note This is documented as a variable but is actually a method.
      @param [Object] child The child Object to extend.
      @param [Object] parent The parent Object to inheret methods.
     */

    Tweak.prototype["extends"] = extend;


    /*
      Bind a context to a method. For example with 'that' being a different context Tweak.bind(this.pullyMethod, that).
      @note This is documented as a variable but is actually a method.
      @param [Function] fn The function to bind a property to.
      @param [Context] context The context to bing to a function.
     */

    Tweak.prototype.bind = bind;


    /*
      To super a method with JS use Tweak.super(context);. Alternativaly just do (example) Model.__super__.set(this);
      @param [Object] context The context to apply a super call to.
      @param [Obect] that Pass a context to the super call.
      @param [String] name The method name to call super upon.
     */

    Tweak.prototype["super"] = function() {
      var context, name, params, that;
      context = arguments[0], that = arguments[1], name = arguments[2], params = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      return context.__super__[name].apply(that, params);
    };


    /*
      Restore the previous stored Tweak/tweak.
     */

    Tweak.prototype.noConflict = function() {
      if (this.pTweak) {
        root.Tweak = this.pTweak;
      }
      return this;
    };


    /*
      Clone a simple Object to remove reference to original Object or simply to copy it.
      @param [Object, Array] ref Reference Object to clone.
      @return [Object, Array] Returns the copied Object, while removing references.
      @throw An error will be thrown if an object type is not supported.
    
      @example Cloning an Object.
        var obj, obj2;
        obj = {
          test:'test',
          total:4
        }
    
        // Clone the object.
        obj2 = Tweak.Clone(obj);
    
        // Alter the new object without adjusting other Object.
        obj2.test = null
     */

    Tweak.prototype.clone = function(obj, parent) {
      var _new, flags, key;
      if ((obj == null) || typeof obj !== 'object' || obj === parent) {
        return obj;
      }
      if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      if (obj instanceof RegExp) {
        flags = '';
        if (obj.global != null) {
          flags += 'g';
        }
        if (obj.ignoreCase != null) {
          flags += 'i';
        }
        if (obj.multiline != null) {
          flags += 'm';
        }
        if (obj.sticky != null) {
          flags += 'y';
        }
        return new RegExp(obj.source, flags);
      }
      _new = obj instanceof Array ? [] : {};
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          _new[key] = this.clone(obj[key], obj);
        }
      }
      return _new;
    };


    /*
      Similar to Tweak.extends. However this will combine nested objects to make a full cobined object. This should only
      be done with simple objects; as this method can get very expensive.
      @param [Object, Array] ref Reference Object.
      @param [Object, Array] ref Object to merge into.
      @return [Object, Array] Returns the combined Object.
    
      @example Combining an Object.
        var obj, obj2;
        obj = {
          total:{
            laps:10,
            miles:30
          }
        }
    
        obj2 = {
          total:{
            miles:32
          }
        }
    
        // Clone the object.
        Tweak.Combine(obj);
     */

    Tweak.prototype.combine = function(obj, parent) {
      var key, prop;
      for (key in parent) {
        prop = parent[key];
        if (typeof prop === 'object') {
          if (obj[key] == null) {
            obj[key] = prop instanceof Array ? [] : {};
          }
          obj[key] = this.combine(obj[key], prop);
        } else {
          obj[key] = prop;
        }
      }
      return obj;
    };


    /*
      @overload request(context, module, surrogate)
        Require/request a module from given context and path or return a surrogate.
        @param [String] context The context path.
        @param [String] module The module path to convert to absolute path, based on the context path.
        @param [*] surrogate (Optional) A surrogate that can be used if there is no module found.
        @return [*] Returns found module or surrogate.
    
    
      @overload request(contexts, module, surrogate)
        Try to find a module by name from multiple context paths returning the first found module. A final surrogate will be
        returned if no modules could be found.
        @param [Array<String>] paths An array of context paths.
        @param [String] module The module path to convert to absolute path; based on the context path.
        @param [*] surrogate (Optional) A surrogate that can be used if there is no module found.
        @return [*] Returns found module or surrogate.
    
      @throw When a module is not found and there is no surrogate an error will be thrown -
      "No module #{module name} for #{component name}".
    
      @example Request 'template' module from contexts of ['app/index', 'components/page']
        Tweak.request(['app/index', 'components/page'], './template');
        // Returns template module if found in any of the contexts or throws error
    
      @example Request 'template' module from contexts of ['app/index', 'components/page'], if not found a surrogate is used
        var sur;
        sur = {
          body:'<body></body>'
        }
        Tweak.request(['app/index', 'components/page'], './template', surr);
        // Returns template module if found or returns the surrogate
     */

    Tweak.prototype.request = function(contexts, module, surrogate) {
      var context, e, error, j, len;
      if (typeof contexts === 'string') {
        contexts = [contexts];
      } else if (contexts.length === 0) {
        contexts[0] = '';
      }
      for (j = 0, len = contexts.length; j < len; j++) {
        context = contexts[j];
        try {
          return this.require(tweak.toAbsolute(context, module));
        } catch (error) {
          e = error;
          if (e.name !== 'Error') {
            throw e;
          }
        }
      }
      if (surrogate != null) {
        return surrogate;
      }
      throw new Error("No module " + module + " for " + contexts[0]);
    };

    splitPathReg = /^(.*)\[(\d*)(?:[,\-](\d*)){0,1}\](.*)$/;


    /*
      Split a path formated as a 'multi-path' into individual paths.
      @param [Array<String>, String] paths 'multi-path's to format.
      @return [Array<String>] Array of paths.
    
      @example Names formated as './cd[2-4]'
        Tweak.splitPaths('./cd[2-4]');
        // Returns ['./cd2','./cd3','./cd4']
    
      @example Names formated as ['./cd[2]/model', '../what1']
        Tweak.splitPaths(['./cd[2]', '../what1']);
        // Returns ['./item0/model','./item1/model','./item2/model', '../what1']
    
      @example Names formated as single space delimited String './cd[2]/model ../what1'
        Tweak.splitPaths('./cd[2]/model ../what1');
        // Returns ['./item0/model','./item1/model','./item2/model', '../what1']
     */

    Tweak.prototype.splitPaths = function(paths) {
      var j, k, len, match, max, min, num, path, prefix, ref, ref1, results, suffix;
      if (typeof paths === 'string') {
        paths = paths.split(/\s+/);
      }
      results = [];
      for (j = 0, len = paths.length; j < len; j++) {
        path = paths[j];
        match = splitPathReg.exec(path);
        if (match != null) {
          path = match[0], prefix = match[1], min = match[2], max = match[3], suffix = match[4];
          for (num = k = ref = (max == null ? 0 : min), ref1 = max || min; ref <= ref1 ? k <= ref1 : k >= ref1; num = ref <= ref1 ? ++k : --k) {
            results.push("" + prefix + num + suffix);
          }
        } else {
          results.push(path);
        }
      }
      return results;
    };

    affixReg = /^(\.+[\/\\]+)+/;

    upReg = /(\.{2,}[\/\\]+)/g;

    rootReg = /^(~+[\/\\]+)/;

    slashReg = /[\/\\]+/g;


    /*
      Convert a relative path to an absolute path; relative path defined by ./ or .\ It will also
      navigate up per defined ../.
      @param [String] context The path to navigate to find absolute path based on given relative path.
      @param [String] relative The relative path to convert to absolute path.
      @return [String] Absolute path based upon the given context and relative path.
    
    
      @example Create absolute path from context of "albums/cds/songs"  with a path of '../cd1'
        Tweak.toAbsolute('albums/cds/songs', '../cd1');
        // Returns 'albums/cds/cd1'
    
      @example Create absolute path from context of "album1/cd1"  with a path of './beautiful'
        Tweak.toAbsolute('album1/cd1', './beautiful');
        // Returns 'album1/cd1/beautiful'
     */

    Tweak.prototype.toAbsolute = function(context, relative) {
      var amount, reduceReg, ref;
      relative = relative.replace(slashReg, '/');
      context = context.replace(slashReg, '/');
      if (relative.match(rootReg)) {
        return relative.replace(rootReg, '').replace(affixReg, '');
      }
      amount = ((ref = relative.match(upReg)) != null ? ref.length : void 0) || 0;
      reduceReg = RegExp("([\\/\\\\]*[^\\/\\\\]+){" + amount + "}[\\/\\\\]?$");
      relative = relative.replace(affixReg, (context.replace(reduceReg, '')) + "/");
      return relative.replace(/^[\/\\]+/, '');
    };

    return Tweak;

  })();

  Tweak = (function() {

    /*
      Assign root as either self, global or window.
     */
    var $, exports, item, j, len, ref, root;
    root = (typeof self === 'object' && self.self === self && self) || (typeof global === 'object' && global.global === global && global) || window;
    if (typeof exports !== 'undefined') {

      /*
        CommonJS and Node environment; including brunch.
        Dom manipulator assigned to $ will take piority
       */
      ref = ['jquery', 'zepto', 'ender', '$'];
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (!$) {
          try {
            $ = root.require(item);
          } catch (undefined) {}
        }
      }
      return typeof module !== "undefined" && module !== null ? module.exports = exports = new Tweak(root, root.require, $ || root.$) : void 0;
    } else {

      /*
        Typical web environment.
       */
      return root.tweak = root.Tweak = new Tweak(root, root.require, root.jQuery || root.Zepto || root.ender || root.$);
    }
  })();


  /*
    Tweak.js has an event system class, this provides functionality to extending classes to communicate simply and
    effectively while maintaining an organised structure to your code and applications. Each object can extend the
    Tweak.EventSystem class to inherit event functionality. Majority of Tweak.js modules/classes already extend
    the EventSystem class, however when creating custom objects/classes you can extend the class using the Tweak.extends
    method or your chosen language's extends method.
    
    The event system is bound to an object instance that extends the Tweak.Events Class. By bounding a Event system to
    an instance you keep your event structure focused and accurate; avoiding confusion with complex event scopes. Event
    names can be name spaced by any character, but you should keep the same name spacing structure as each structure will
    be treated as unique. The typical character is to use is a ':'; so an example of a event name will be 'changed:name'.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Events = (function() {
    function Events() {}


    /*
      Empty secondary constructor method
     */

    Events.prototype.__constructor = function() {};


    /*
      Iterate through bound events to find matching events. The method can also be used to construct an event by passing
      an optional true value Boolean argument.
    
      @overload findEvent(names, build)
        Find events with a space separated string.
        @param [String] names The event name(s); split on a space.
        @param [Boolean] build (Default = false) Whether or not to add an event object when none can be found.
        @return [Array<Event>] All event objects that are found/created then it is returned in an Array.
    
      @overload findEvent(names, build)
        Find events with an array of names (strings).
        @param [Array<String>] names An array of names (strings).
        @param [Boolean] build (Default = false) Whether or not to add an event object when none can be found.
        @return [Array<Event>] All event objects that are found/created then it is returned in an Array.
    
      @example Delimited string
        // This will find all events in the given space delimited string.
        var model;
        model = new Model();
        model.findEvent('sample:event another:event');
    
      @example Delimited string with build
        // This will find all events in the given space delimited string.
        // If event cannot be found then it will be created.
        var model;
        model = new Model();
        model.findEvent('sample:event another:event', true);
    
      @example Array of names (strings)
        // This will find all events from the names in the given array.
        var model;
        model = new Model();
        model.findEvent(['sample:event', 'another:event']);
    
      @example Array of names (strings) with build
        // This will find all events from the names in the given array.
        // If event cannot be found then it will be created.
        var model;
        model = new Model();
        model.findEvent(['sample:event', 'another:event'], true);
     */

    Events.prototype.findEvent = function(names, build) {
      var event, events, j, len, name, results1;
      if (build == null) {
        build = false;
      }
      if (typeof names === 'string') {
        names = names.split(/\s+/);
      }
      events = this.__events = this.__events || {};
      results1 = [];
      for (j = 0, len = names.length; j < len; j++) {
        name = names[j];
        if (!(event = events[name])) {
          if (build) {
            event = this.__events[name] = {
              name: name,
              __callbacks: []
            };
          } else {
            continue;
          }
        }
        results1.push(event);
      }
      return results1;
    };


    /*
      Bind a callback to the event system. The callback is invoked when an event is triggered. Events are added to an
      object based on their name. Name spacing is useful to separate events into their relevant types. It is typical to
      use colons for name spacing, Default Tweak events will use the colon character as its name spacing. However you can
      use any other name spacing characters such as / \ - _ or . Please keep in mind that if you vary the name spacing the
      events will be treated as unique.
      
      @overload addEvent(names, callback, context, max)
        Bind a callback to event(s) with context and/or total calls
        @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @param [Function] callback The event callback function.
        @param [Object] context (optional, default = this) The contextual object of which the event to be bound to.
        @param [Number] max (optional, default = null). The maximum calls on the event listener. After the total calls
        the events callback will not invoke.
    
      @overload addEvent(names, callback, max, context)
        Bind a callback to event(s) with total calls and/or context
        @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @param [Function] callback The event callback function.
        @param [Number] max The maximum calls on the event listener. After the total calls the events callback will not invoke.
        @param [Object] context (optional, default = this) The contextual object of which the event to be bound to.
    
      @example Bind a callback to event(s)
        var model;
        model = new Model();
        model.addEvent('sample:event', function(){
          alert('Sample event triggered.')
        });
      
      @example Bind a callback to event(s) with total calls
        var model;
        model = new Model();
        model.addEvent('sample:event', function(){
          alert('Sample event triggered.')
        }, 4);
    
      @example Bind a callback to event(s) with a separate context without total calls
        var model;
        model = new Model();
        model.addEvent('sample:event', function(){
          alert('Sample event triggered.')
        }, this);
    
      @example Bind a callback to event(s) with a separate context with maximum calls
        var model;
        model = new Model();
        model.addEvent('sample:event', function(){
          alert('Sample event triggered.')
        }, this, 3);
     */

    Events.prototype.addEvent = function(names, callback, context, max) {
      var event, item, j, k, len, len1, ref, ref1, ref2, toAdd;
      if (context == null) {
        context = this;
      }
      if (typeof context === 'number' || (context == null)) {
        if (max == null) {
          max = this;
        }
        ref = [context, max], max = ref[0], context = ref[1];
      }
      ref1 = this.findEvent(names, true);
      for (j = 0, len = ref1.length; j < len; j++) {
        event = ref1[j];
        toAdd = true;
        ref2 = event.__callbacks;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          item = ref2[k];
          if (item.callback === callback && context === item.context) {
            item.max = max != null ? max : item.max;
            item.calls = 0;
            item.listen = !(toAdd = false);
          }
        }
        if (toAdd) {
          event.__callbacks.push({
            context: context,
            callback: callback,
            max: max,
            calls: 0,
            listen: true
          });
        }
      }
    };


    /*
      Remove a previously bound callback function. Removing events can be limited to context and its callback. This will
      destroy references to the callback event. To stop listening to an event without removing the event use the
      updateEvent method.
    
      @param [String] names The event name(s). Split on a space, or an array of event names.
      @param [Function] callback (optional) The callback function of the event. If an event has a matching callback or
      callback argument is null it will be removed, however removing this event will be limited to the context argument.
      @param [Object] context (default = this) The contextual object of which the event is bound to. If an event has a
      matching context or context argument is null it will be removed, however removing this event will be limited to the
      callback argument.
    
      @example Unbind a callback from event(s)
        var model;
        model = new Model();
        model.removeEvent('sample:event another:event', @callback);
    
      @example Unbind all callbacks from event(s)
        var model;
        model = new Model();
        model.removeEvent('sample:event another:event');
     */

    Events.prototype.removeEvent = function(names) {
      var callback, context, event, item, j, k, key, len, len1, ref, ref1, ref2, toDelete;
      callback = arguments.length >= 2 ? arguments[1] : false;
      context = arguments.length >= 3 ? arguments[2] : false;
      ref = this.findEvent(names);
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        toDelete = [];
        ref1 = event.__callbacks;
        for (key in ref1) {
          item = ref1[key];
          if ((!callback || callback === item.callback) && (!context || context === item.context)) {
            toDelete.push(key);
          }
        }
        if (toDelete.length === event.__callbacks.length) {
          delete this.__events[event.name];
        } else {
          ref2 = toDelete.reverse();
          for (k = 0, len1 = ref2.length; k < len1; k++) {
            key = ref2[k];
            event.__callbacks.splice(key, 1);
          }
        }
      }
    };


    /*
      Trigger event callbacks by name. Triggers can be limited to matching context. When triggering an event you may pass
      as many arguments to the callback method.
    
      @overload triggerEvent(names, params)
        Trigger events by name only.
        @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @param [...] params Parameters to pass into the callback function.
    
      @overload triggerEvent(options, params)
        Trigger events by name and context.
        @param [Object] options Options and limiters to check against callbacks.
        @param [...] params Parameters to pass into the callback function.
        @option options [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @option options [Context] context (Default = null) The context of the callback to check against a callback.
    
      @example Triggering event(s)
        var model;
        model = new Model();
        model.triggerEvent('sample:event, another:event');
    
      @example Triggering event(s) with parameters
        var model;
        model = new Model();
        model.triggerEvent('sample:event another:event', 'whats my name', 'its...');
    
      @example Triggering event(s) but only with matching context
        var model;
        model = new Model();
        model.triggerEvent({context:@, name:'sample:event another:event'});
     */

    Events.prototype.triggerEvent = function() {
      var context, event, item, j, k, len, len1, names, params, ref, ref1, ref2;
      names = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (typeof names === 'object' && !(names instanceof Array)) {
        ref = names, names = ref.names, context = ref.context;
      }
      ref1 = this.findEvent(names);
      for (j = 0, len = ref1.length; j < len; j++) {
        event = ref1[j];
        ref2 = event.__callbacks;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          item = ref2[k];
          if (item.listen) {
            if (!context || context === item.context) {
              if (++item.calls >= item.max && (item.max != null)) {
                item.listen = false;
              }
              setTimeout((function() {
                this.callback.apply(this.context, params);
              }).bind(item), 0);
            }
          }
        }
      }
    };


    /*
      Update an event. With this method it is possible to set the events listening state, maximum calls, and total calls
      while limiting updated events by name and optional callback and/or context.
      @param [String] names The event name(s). Split on a space, or an array of event names.
      @param [Object] options Optional limiters and update values.
      @option options [Object] context The contextual object to limit updating events to, this is a combined limiter, the
      value of the callback option will determine the events to update.
      @option options [Function] callback Callback function to limit updating events to, this is a combined limiter, the
      value of the context option will determine the events to update.
      @option options [Number] max Set a new maximum amount of allowed calls for an event.
      @option options [Number] calls Set the amount of calls that has been triggered on this event.
      @option options [Boolean] reset (Default = false) If true then calls on an event get set back to 0.
      @option options [Boolean] listen Whether to enable or disable listening state of an event.
    
      @example Updating event(s) to not listen
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {listen:false});
    
      @example Updating event(s) to not listen, however limited by optional context and/or callback
        // Limit events that match to a context and callback.
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {context:@, callback:@callback, listen:false});
    
        // Limit events that match to a callback.
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {callback:@anotherCallback, listen:false});
    
        // Limit events that match to a context.
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {context:@, listen:false});
    
      @example Updating event(s) maximum calls and reset its current calls
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {reset:true, max:100});
    
      @example Updating event(s) total calls
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {calls:29});
     */

    Events.prototype.updateEvent = function(names, options) {
      var callback, calls, context, event, item, j, k, len, len1, listen, max, ref, ref1, reset;
      if (options == null) {
        options = {};
      }
      context = options.context, max = options.max, reset = options.reset, calls = options.calls, listen = options.listen, callback = options.callback;
      if (reset) {
        calls = 0;
      }
      ref = this.findEvent(names);
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        ref1 = event.__callbacks;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          item = ref1[k];
          if ((!context || context === item.context) && (!callback || callback === item.callback)) {
            if (max != null) {
              item.max = max;
            }
            if (calls != null) {
              item.calls = calls;
            }
            if (listen != null) {
              item.listen = listen;
            }
            if ((item.max != null) && item.max <= item.calls) {
              item.listen = false;
            }
          }
        }
      }
    };


    /*
      Resets the events on this object to empty.
     */

    Events.prototype.resetEvents = function() {
      return this.__events = {};
    };

    return Events;

  })();


  /*
    A Model is used to store, retrieve and listen to attributes.Tweak.js will call events through its **event system**,
    when the Model is updated when it will trigger a 'changed' event. By listening to change events, you can action
    functionality upon changes to the Model's attributes. The Model’s attributes are not perisistant, as such it is not a
    storage medium, but a layer for actioning functionailty upon changes. The Model's data can be exported as a JSON
    represtaion which can be used to store/retrieve data form persistant storage sources. The main difference between a
    Model and collection it the base of its attributes. The Model uses an Object as its attributes base and a collection
    uses an Array as its attributes base, to add the Collection Class extends the Model Class.
  
    A Model based class has a getter and setter system. So you can easily apply additional functionality when setting or
    getting an attribute. When calling the set method, a setter method may be called if a setter to the naming convention
    of 'setter_{property name}' exists. The returning value of the setter method will be used in setting the attribute.
    When calling the get method, a getter method may be called if a getter to the naming convention of
    'getter_{property name}' exists. The value of the getter method will be used at the result of the get call. Setters
    and getters can also have additional parameters passed to them to provide extra logic. When setting or getting
    multiple attributes each set of parameters should be contained in a multidimesional Array. For example this is the
    structure when setting on attribute model.set('pizza', 'cheesy', ['extra', 'cheesy', 'please']);. If you where
    to set/get multiple attributes then this would be the structure to pass extra parameters to the setter/getter.
    model.set({'pizza':'cheesy', price:20}, ['extra cheesy'], [10, 50]);.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
  
    @example Creating a setter and getter in Model.
      // This example is very trivial but it illustrates some use of setters and getters
      var QuestionModel, _model, exports;
  
      module.exports = exports = QuestionModel = (function() {
        function QuestionModel() {}
  
        Tweak.extends(QuestionModel, Tweak.Model);
  
        // Correct getter will return true or false
        QuestionModel.prototype.getter_correct = function(_prev) {
          _correct = this.get('answer') === this.get('correct_answer');
          // You can use a getter to compare to the previous value
          if (_prev === true && _correct === false) {
            alert('You already got this correct, you should know the answer!');
          }
          // You can use the model value as a private property to later use as a comparison
          // In this instance when answer has been answered correct it will be saved to model
          if (_correct === true) {
            // Set correct silently
            this.set('correct', true, true);
          }
          return _correct
        };
  
        // The answer may only be in the range of 0 - 100
        // This setter will auto validate the answer to within the range, while if its not in range it will trigger an
        // event from the model. For example a notification could be displayed letting the user know his answer was
        QuestionModel.prototype.setter_answer = function(value) {
          var error;
          error = value > 100 ? 'above' : value < 0 ? 'below' : null;
          if (error) {
            this.trigger('error:range:' + error, value);
          }
          if (error < 0) {
            return 0;
          } else if (value > 100) {
            return 100;
          } else {
            return value;
          }
        };
  
        return QuestionModel;
  
      })();
  
      // Create a new QuestionModel where the answer correct_answer is 10
      _model = new QuestionModel({
        correct_answer: 10
      });
  
      // Listen to answer being set alerting whether the user has got the answer correct
      _model.addEvent('changed:answer', function() {
        return alert('Answer is ' + (this.get('correct') ? 'Correct' : 'Wrong'));
      });
  
      // Listen range error - lets the user knows that his answer was above range
      _model.addEvent('error:range:above', function(value) {
        return alert('Answer (' + value + ') is above max range of 100, answer has been altered to 100');
      });
  
      // Listen range error - lets the user knows that his answer was above range
      _model.addEvent('error:range:below', function(value) {
        return alert('Answer (' + value + ') is below min range of 100, answer has been altered to 0');
      });
  
      // Alerts 'Answer is Wrong'
      _model.set('answer', 20);
  
      // Alerts 'Answer (500) is above max range of 100, answer has been altered to 100'
      // Alerts 'Answer is Wrong'
      _model.set('answer', 500);
  
      // Alerts 'Answer is Correct'
      _model.set('answer', 10);
  
      // Alerts 'You already got this correct, you should know the answer!'
      // Alerts 'Answer is wrong'
      _model.set('answer', 5);
   */

  Tweak.Model = (function(superClass) {
    var __fullTrigger;

    extend(Model, superClass);

    Model.prototype.__base = function() {
      return {};
    };

    Model.prototype.length = 0;


    /*
      Method to trigger a change event for all of the properties in the Collection
     */

    __fullTrigger = function(ctx) {
      var item, key, ref, results1;
      ref = ctx.attributes;
      results1 = [];
      for (key in ref) {
        item = ref[key];
        results1.push(ctx.triggerEvent("changed:" + key, item));
      }
      return results1;
    };


    /*
      The constructor will set the initial attributes. The attributes set at this point will be applied silently.
    
      @example Creating a Collection with predefined set of attributes.
        var collection;
        collection = new tweak.Collection([
          new Tweak.Model({drink:'Pepsi'}),
          new Tweak.Model({drink:'Lemonade'})
        ]);
    
      @example Creating a Model with predefined set of attributes
        var model;
        model = new tweak.Model({
          'demo':true,
          'example':false,
          'position':99
        });
     */

    function Model(attributes) {
      var item;
      if (attributes == null) {
        attributes = this.__base();
      }
      this.attributes = attributes;
      for (item in attributes) {
        this.length++;
      }
    }


    /*
      Default initialiser function. By default this is empty, upon initialisation of a component this will be called.
      This acts as your constructor, giving you access to the other modules of the component. Please note you can use a
      constructor method but you will not have access to other modules.
     */

    Model.prototype.init = function() {};


    /*
      Set attribute(s), upon setting an attribute there will be an event triggered; you can use this to listen to changes
      and act upon the changes as required. There is also a final generic changed event fired.
    
      @overload set(data, silent, params)
        Set multiple attributes by an object of data.
        @param [Object] data Key and property based object.
        @param [Boolean] silent (optional, default = false) Trigger 'changed' events upon changes to attribute.
        @param [Array<Array<*>>] params Additional parameters in an multidimensional Array to pass to setters. Each
        key in the object will need its own set of additional parameters.
        @return [Number] Length of attributes.
    
      @overload set(name, data, silent, params)
        Set an individual attribute by the name (String).
        @param [String] name The name of the attribute.
        @param [*] data Attribute value.
        @param [Array<*>] params Additional parameters in an Array to pass to getter.
        @param [Boolean] silent (optional, default = false) Trigger 'changed' events upon changes to attributes.
        @return [Number] Length of attributes.
    
      @example Setting single attribute.
        this.set('sample', 100);
    
      @example Setting multiple attributes.
        this.set({sample:100, second:2});
    
      @example Setting attributes silently, with additional parameters to pass to setters.
        this.set('sample', 100, true, [false, true, 50]);
        this.set({sample:100, second:2}, true, [
          [200],
          [true, true]
        ]);
    
      @event changed:#{key} Triggers an event of the changed attribute, with the value of the new attribute.
      @event changed Triggers a generic event that the attributes have been updated, with changed attributes and values.
     */

    Model.prototype.set = function(data, silent, arg3, params) {
      var _data, attr, changed, fn, i, key, type;
      type = typeof data;
      if (type === 'string' || type === 'number') {
        (_data = {})[data] = silent;
        data = _data;
        silent = arg3;
        params = [params];
      } else {
        params = arg3 || [];
      }
      changed = this.__base();
      i = 0;
      for (key in data) {
        attr = data[key];
        if (this.attributes[key] == null) {
          this.length++;
        }
        fn = this["setter_" + key];
        changed[key] = this.attributes[key] = fn != null ? ((params[i] != null ? params[i] : params[i] = []).unshift(attr), fn.apply(this, params[i])) : attr;
        i++;
        if (!silent) {
          this.triggerEvent("changed:" + key, changed[key]);
        }
      }
      if (!silent) {
        this.triggerEvent('changed', changed);
      }
      return this.length;
    };


    /*
      It is possible to limit attributes by passing a array of attribute names of a single attribute name. If you want to
      retrieve all attributes then don't pass a limiter.
    
      @note When passing additional params
    
      @overload get(name, params)
        Get an individual attribute.
        @param [String] name The name of the attribute.
        @param [Array<*>] params Additional parameters in an Array to pass to getter.
        @return [Array<*>, Object, *] Value of attribute.
    
      @overload get(limit, params)
        Get multiple attributes.
        @param [Array<String>] limit Array of attribute names.
        @param [Array<Array<*>>] params Additional parameters in an multidimensional Array to pass to getters. Each
        item in the get limiter will need its own set of additional parameters.
        @return [Array<*>, Object] Values of attributes.
    
      @example Get attribute.
        this.get('sample');
    
      @example Get mutiple attributes.
        this.get(['sample', 'pizza']);
     */

    Model.prototype.get = function(limit, params) {
      var attr, attributes, data, fn, i, item, j, len, typeArray;
      if (params == null) {
        params = [];
      }
      if (!(limit instanceof Array)) {
        limit = [limit];
        params = [params];
      }
      attributes = this.__base();
      typeArray = attributes instanceof Array;
      for (i = j = 0, len = limit.length; j < len; i = ++j) {
        item = limit[i];
        fn = this["getter_" + item];
        attr = this.attributes[item];
        data = fn != null ? ((params[i] != null ? params[i] : params[i] = []).unshift(attr), fn.apply(this, params[i])) : attr;
        attributes[typeArray ? i : item] = data;
      }
      if (i <= 1) {
        attributes = attributes[typeArray ? 0 : item];
      }
      return attributes;
    };


    /*
      Remove attribute(s).
    
     @overload remove()
        Remove all attributes.
        @return [Number] Length of attributes.
    
      @overload remove(name)
        Get an individual attribute by attribute name.
        @param [String] name The name of the attribute.
        @return [Number] Length of attributes.
    
      @overload remove(limit)
        Get multiple attributes from base storage.
        @param [Array<String>] limit Array of attribute names.
        @return [Number] Length of attributes.
    
      @event changed:#{key} Triggers an event of the changed attribute, with the value of the new attribute.
      @event changed Triggers a generic event that the attributes have been updated, with changed attributes and values.
    
      @example Removing a single attribute.
        var model;
        model = new tweak.Model();
        model.remove('demo');
    
      @example Removing multiple attributes.
        var model;
        model = new tweak.Model();
        model.remove(['demo', 'example']);
    
      @example Removing attributes silently.
        var model;
        model = new tweak.Model();
        model.remove(['demo', 'example'], true);
        model.remove('position', true);
     */

    Model.prototype.remove = function(limit, silent) {
      var attribute, i, isArray, j, len;
      if (!(limit instanceof Array)) {
        limit = [limit];
      }
      isArray = this.__base() instanceof Array;
      i = 0;
      for (j = 0, len = limit.length; j < len; j++) {
        attribute = limit[j];
        if (isArray) {
          attribute = attribute - i;
        }
        if (this.attributes[attribute] != null) {
          this.length--;
          if (isArray) {
            this.attributes.splice(attribute, 1);
          } else {
            delete this.attributes[attribute];
          }
          if (!silent && !isArray) {
            this.triggerEvent("changed:" + attribute);
          }
          i++;
        }
      }
      if (!silent) {
        if (isArray) {
          __fullTrigger(this);
        }
        this.triggerEvent('changed');
      }
      return this.length;
    };


    /*
      Checks the existence of attribute(s).
    
      @overload has(name, params)
        Check the existence of a single attribute.
        @param [String] name The name of the attribute.
        @param [Array<*>] params Additional parameters in an Array to pass to getter.
        @return [Boolean] Attribute existence.
    
      @overload has(limit, params)
        Check the existence of multiple attributes.
        @param [Array<String>] limit Array of attribute names.
        @param [Array<Array<*>>] params Additional parameters in an multidimensional Array to pass to getters. Each
        item in the get limiter will need its own set of additional parameters.
        @return [Boolean] Attributes existence.
    
      @example Check the existence of a single attribute.
        this.has('sample');
    
      @example Check the existence of multiple attributes.
        this.has(['sample', 'pizza']);
     */

    Model.prototype.has = function(limit, params) {
      var attr, attributes, key;
      attributes = this.get(limit, params);
      if (!(limit instanceof Array)) {
        attributes = [attributes];
      }
      for (key in attributes) {
        attr = attributes[key];
        if (attr === void 0 || (attr == null)) {
          return false;
        }
      }
      return true;
    };


    /*
      Returns whether two objects are the same (similar).
      @param [Object, Array] one Object to compare to Object two.
      @param [Object, Array] two Object to compare to Object one.
      @return [Boolean] Are the two Objects the similar?
    
      @example comparing objects.
        this.same({'sample':true},{'sample':true}); //true
        this.same({'sample':true},{'not':true}); //false
     */

    Model.prototype.same = function(one, two) {
      var key, prop;
      if (two == null) {
        two = this.attributes;
      }
      for (key in one) {
        prop = one[key];
        if ((two[key] == null) || prop !== two[key]) {
          return false;
        }
      }
      for (key in two) {
        prop = two[key];
        if ((one[key] == null) || prop !== one[key]) {
          return false;
        }
      }
      return true;
    };


    /*
      This method directly accesses the Collection's attributes's toString method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString
     */

    Model.prototype.toString = function() {
      return this.attributes.toString();
    };


    /*
      This method directly accesses the Collection's attributes's toLocalString method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocalString
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocalString
     */

    Model.prototype.toLocaleString = function() {
      return this.attributes.toLocaleString();
    };


    /*
      Returns an Array of attribute names where the attribute value matches.
      @param [*] value Value to check.
      @return [Array<String>] Returns an Array of attribute names where the attribute value matches argument.
    
      @example Find attribute names where value matches attributes.
        this.where(1009); //[3,87]
     */

    Model.prototype.where = function(value) {
      var attr, key, ref, results1;
      ref = this.attributes;
      results1 = [];
      for (key in ref) {
        attr = ref[key];
        if (attr === value) {
          results1.push(key);
        }
      }
      return results1;
    };


    /*
      Reset the attributes and set length to 0 and triggers 'changed' event.
      @event changed Triggers a generic event that the attributes have been updated.
     */

    Model.prototype.reset = function() {
      this.length = 0;
      this.attributes = this.__base();
      this.triggerEvent('changed');
    };


    /*
      Import attributes, attributes can be imported silently. The import method will overwrite attributes that already
      exists; if the existing attribute value has an import method the data will be passed to the attributes' method.
    
      @param [Object, Array] attributes Attribute data to import.
      @param [Boolean] silent (optional, default = false) Trigger 'changed' events upon changes to attributes.
      @return [Number] Length of attributes.
    
    
      @event changed:#{key} Triggers an event of the changed attribute, with the value of the new attribute.
      @event changed Triggers a generic event that the attributes have been updated, with changed attributes and values.
     */

    Model.prototype["import"] = function(attributes, silent) {
      var attr, key, value;
      if (silent == null) {
        silent = true;
      }
      for (key in attributes) {
        attr = attributes[key];
        value = this.get(key);
        if ((value != null ? value["import"] : void 0) != null) {
          value["import"](attr, silent);
        } else {
          this.set(key, attr, true);
          if (!silent) {
            this.triggerEvent("changed:" + key);
          }
        }
      }
      if (!silent) {
        this.triggerEvent('changed');
      }
    };


    /*
      Export attributes, the exported attributes can be limited by an Array of attribute names. If the attribute value has
      an export method then value will be equal to the returned value.
    
      @param [Array<String>] limit (default = all attributes) Limit attributes to export.
      @return [Object] Exported attributes.
     */

    Model.prototype["export"] = function(limit) {
      var _limit, isArray, item, key, limiter, nKey, result, value;
      result = this.__base();
      if (limit == null) {
        limit = (function() {
          var ref, results1;
          ref = this.attributes;
          results1 = [];
          for (key in ref) {
            item = ref[key];
            results1.push(key);
          }
          return results1;
        }).call(this);
      }
      isArray = result instanceof Array;
      for (key in limit) {
        limiter = limit[key];
        if (limiter instanceof Object) {
          _limit = limiter.limit;
          limiter = limiter.name;
        }
        nKey = Number(limiter);
        if (isArray && !isNaN(nKey)) {
          limiter = nKey;
        }
        value = this.get(limiter);
        if (value != null) {
          if (typeof value["export"] === 'function') {
            value = value["export"](_limit);
          }
          if (isArray && typeof limiter === 'number') {
            result.push(value);
          } else {
            result[limiter] = value;
          }
        }
      }
      return result;
    };

    return Model;

  })(Tweak.Events);


  /*
    A View is a module to clearly define and separate the user interface functionality. A View is primarily used to render
    , manipulate and to listen to actions on a user interface. The view keeps data logic separated away from the UI, this
    is to leverage better code structure to prevent Data and the UI becoming tangled together.
  
    Tweak.js provides default functionality to render a template; like handlebars. Currently handlebars is used as default
    as the render. This will be separated out into an extension in a later version. Tweak.js's View can utilize two
    different methods to render a template. It also allows you to point directly to a element to use as the 'view area'
    examples below. The rendering methods include adding a data-attach attribute to an element; Tweak js will look at
    these attributes values to find where to attach a template to. If that not your scene you can also specify a selector
    to determine where to attach to.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
  
    @example Static view
      var MainView;
  
      // This will create a view that points to an element with an id of "mainElement".
      MainView = new Tweak.View({
        method:"static",
        element:"#mainElement"
      });
  
      // Override the ready method to apply your logic - this will be called when the View is rendered.
      MainView.ready = function() {
        console.log(MainView.el); // Outputs the "#mainElement" element
      }
  
      // This must be called to initialise the view correctly
      MainView.init();
  
      // Called to invoke the View
      MainView.render();
   */

  Tweak.View = (function(superClass) {
    var $, _async, _attach, _classNames, _data, _name, _parentElement, _parentName, _paths;

    extend(View, superClass);

    $ = Tweak.$;


    /*
      The constructor passes a config object that will be used upon the initialization of the view module. Use of the
      options is described below. Not all options need to be provided; when using component modules some of the option
      values will automatically be provided.
    
      @param [Object] config A configuration object that is used to describe how the View is initialised and rendered.
    
      @option config [String] name When using a View independently to Component modules this will be used to name the view
      Used in instances to apply a className to the Views main element, and will be used to find where to attach to; by
      default othe values will look at this so it is recommended each view has a name. When using Component modules this
      will use the Views relating component name.
    
      @option config [String] parentName When using a View independently to Component modules this can be is used to
      generate an absolute name to compare data-attach values to. This will be populated when using Component modules but
      you may overwrite the value if you wish. When using Component modules the default value will be the parent
      Component's name.
    
      @option config [*] data Use this to pass data to the view when using a View independently of a component, can
      reference a Model or Collection or just be any data type.
    
      @option config [String, DOMElement] element This is used to specify what element to attach to if directly attaching
      to an element using a DOM manipulation framework; if a static View is defined then this option is depended upon.
    
      @option config [String] attach This is used to specify where to attach to if using data-attach attributes. By
      default this will be equal to the config.name value.
    
      @option config [String, Element] parent When using a View independently to Component modules this can be is used to
      specify the parent element of the View - used to decide where generated template will be attached to. This will
      be populated when using Component modules but you may overwrite the value if you wish.
    
      @option config [String] method This is used to specify how the template is attached to. I.e. 'after' - default,
      'before', position (number), 'replace' or 'static'. If static is specified then the view will be treated as static
      and point directly to an element. This can be used when a template engine is not used.
    
      @option config [Array<String>] paths When using a View independently to Component modules this can be is used to
      specify context paths to use when converting data-attach values to an absolute equivalent. This value is also used
      to generate class names to the apply to the Views element. This will be populated when using Component modules but
      you may overwrite the value if you wish.
    
      @option config [String] template When using a View independently to Component modules this can be is used to
      specify the path of the template. This may also be used with config.paths to find an appropriate template. By
      default the name will be './template'.
    
      @option config [Boolean] async (Default = true) This can be used to turn off asynchronous calls to the ready function.
      This adds performance boosts, as it allows other components to continue rendering while functionality is added to the
      View. This may want to be set to false if for example if this View relies on functionality of another Component's
      View to be rendered successfully.
     */

    function View(config) {
      this.config = config != null ? config : {};
    }

    _name = function() {
      var ref;
      return this.config.name || ((ref = this.component) != null ? ref.name : void 0) || '';
    };

    _parentName = function() {
      var ref;
      return this.config.parentName || ((ref = this.parent) != null ? ref.name : void 0) || '';
    };

    _attach = function() {
      return this.config.attach || _name.call(this);
    };

    _paths = function() {
      var ref;
      return this.config.paths || ((ref = this.component) != null ? ref.paths : void 0) || [];
    };

    _classNames = function() {
      var j, len, name, names, results1;
      names = Tweak.clone(_paths.call(this));
      name = _name.call(this);
      if (names.indexOf(name) === -1) {
        names.unshift(name);
      }
      results1 = [];
      for (j = 0, len = names.length; j < len; j++) {
        name = names[j];
        results1.push(name.replace(/[\/\\]+/g, '-'));
      }
      return results1;
    };

    _async = function() {
      var ref;
      return (ref = this.config.async) != null ? ref : true;
    };

    _parentElement = function() {
      var ref, ref1;
      return $(this.config.parentElement)[0] || ((ref = this.parent) != null ? (ref1 = ref.view) != null ? ref1.el : void 0 : void 0) || document.documentElement;
    };

    _data = function() {
      var ref, ref1;
      return (ref = this.config.data) != null ? ref : (ref1 = this.model) != null ? ref1.attributes : void 0;
    };


    /*
      Default initialiser function - called when the View is initialised - this doesn't mean the view will be rendered.
      Use the ready method for applying methods functionality when the view has been rendered.
     */

    View.prototype.init = function() {};


    /*
      Default initialiser function for when the view is rendered. This is empty by default.
     */

    View.prototype.ready = function() {};


    /*
      Default template creation method - this will generate a template from data passed in. By default Tweak.js supports
      handlebar templates that are requirable. This will be separated out into an extension in a later version.
    
      @param [Object] data An object that can be passed to the template.
      @return [String] String representation of HTML to attach to View during render.
     */

    View.prototype.template = function(data) {
      var paths, template;
      template = this.config.template;
      paths = _paths.call(this);
      return (template ? Tweak.request(paths, template) : Tweak.request(paths, './template'))(data);
    };


    /*
      Default attach method. This is used to attach a HTML string to an element. You can override this method with your
      own attachment functionality.
    
      @param [DOMElement] parent A DOMElement used as the parent Element to attach the content element to.
      @param [String, DOMElement] content A element of a HTML String that will be converted to a HTMLElement. This is
      element will be attached to the parent element.
      @return [DOMElement] Attached DOMElement (content).
     */

    View.prototype.attach = function(parent, content, method) {
      var e, error, item, j, len, num, ref;
      if (method == null) {
        method = this.config.method;
      }
      content = $(content)[0];
      switch (method) {
        case 'prefix':
        case 'before':
          parent.insertBefore(content, parent.firstChild);
          return parent.firstElementChild;
        case 'replace':
          ref = parent.children;
          for (j = 0, len = ref.length; j < len; j++) {
            item = ref[j];
            try {
              parent.removeChild(item);
            } catch (error) {
              e = error;
            }
          }
          parent.appendChild(content);
          return parent.firstElementChild;
        default:
          if (!isNaN(num = Number(method))) {
            parent.insertBefore(content, parent.children[num]);
            return parent.children[num];
          } else {
            parent.appendChild(content);
            return parent.lastElementChild;
          }
      }
    };


    /*
      Checks to see if the item is attached to a parent element. This is determined if an parent element contains a
      child element.
      @param [DOMElement, String] parent The parent element or a String representing a selector query, to check if the
      element contains the specified 'containing' element.
      @param [DOMElement, String] parent The 'containing' element or a String representing a selector query.
      @return [Boolean] Does the parent contain an element?
     */

    View.prototype.isAttached = function(element, parent) {
      var _element, _parent, j, k, len, len1;
      parent = $(parent || document.documentElement);
      element = $(element || this.el);
      if (!parent.length || !element.length) {
        return false;
      }
      for (j = 0, len = parent.length; j < len; j++) {
        _parent = parent[j];
        for (k = 0, len1 = element.length; k < len1; k++) {
          _element = element[k];
          if (!$.contains(_parent, _element)) {
            return false;
          }
        }
      }
      return true;
    };


    /*
      Finds an attachment node when using data-attach process.
     */

    View.prototype.getAttachment = function(parent) {
      var attachment, attachments, element, elements, j, k, len, len1, name, parentName, value;
      parent = $(parent)[0];
      if (!parent) {
        return;
      }
      elements = $('[data-attach]', parent).toArray();
      if (parent.getAttribute('data-attach')) {
        elements.unshift(parent);
      }
      parentName = _parentName.call(this);
      name = Tweak.toAbsolute(parentName, _attach.call(this));
      for (j = 0, len = elements.length; j < len; j++) {
        element = elements[j];
        if (!(!attachment)) {
          continue;
        }
        attachments = Tweak.splitPaths(element.getAttribute('data-attach') || '');
        for (k = 0, len1 = attachments.length; k < len1; k++) {
          value = attachments[k];
          if (name === Tweak.toAbsolute(parentName, value)) {
            attachment = element;
            break;
          }
        }
      }
      return attachment;
    };


    /*
      Dynamically renders the view. This will use the views config object to decide the rendering process. Upon rendering
      the View's ready method will be called along with a 'rendered' event being fired. The ready method should be used to
      apply functionality to the Views UI.
    
      @param [Boolean] silent (Optional, default = false) If true events are not triggered upon any changes.
      @event rendered The event is called when the View has been rendered.
     */

    View.prototype.render = function(silent) {
      var _render;
      _render = (function(_this) {
        return function() {
          var _el, _element, attachment, docEl, parentElement;
          if (_this.isAttached() && !silent) {
            return _this.triggerEvent('rendered');
          }
          parentElement = _parentElement.call(_this);
          _element = _this.config.element;
          _el = _this.config.method === 'static' ? $(_element)[0] : (attachment = _element ? $(_element, parentElement)[0] || $(_element)[0] : (docEl = document.documentElement, _this.getAttachment(parentElement) || _this.getAttachment(docEl) || parentElement || docEl), _this.attach(attachment, _this.template(_data.call(_this))));
          _this.$el = $(_el);
          _this.el = _this.$el[0];
          _this.$el.addClass(_classNames.call(_this).join(' '));
          if (!silent) {
            _this.triggerEvent('rendered');
          }
          _this.ready();
        };
      })(this);
      if (_async.call(this)) {
        setTimeout(_render, 0);
      } else {
        _render();
      }
    };


    /*
      Clear and rerender view.
      @param [Boolean] silent (Optional, default = false) If true events are not triggered upon any changes.
      @event rendered The event is called when the View has been rendered.
     */

    View.prototype.rerender = function() {
      this.clear();
      this.render();
    };


    /*
      Clears and element and removes event listeners on itself and child DOM elements.
      @param [String, DOMElement] element A DOMElement or a string representing a selector query.
     */

    View.prototype.clear = function(element) {
      if (element == null) {
        element = this.el;
      }
      $(element).remove();
    };


    /*
      Select a DOMElement from within the assigned view element
      @param [String, DOMElement] element A DOMElement or a string representing a selector query.
      @param [DOMElement] root (Default = @el) The element root to search for elements with a selector engine.
      @return [Array<DOMElement>] An array of DOMElements.
     */

    View.prototype.element = function(element, root) {
      var item, j, len, results1;
      if (root == null) {
        root = this.el;
      }
      if (element instanceof Array) {
        results1 = [];
        for (j = 0, len = element.length; j < len; j++) {
          item = element[j];
          results1.push($(item, root));
        }
        return results1;
      } else {
        return $(element, root);
      }
    };

    return View;

  })(Tweak.Events);


  /*
    A Controller defines the business logic between other modules. It can be used to control data flow, logic and more. It
    should process the data from the Model, interactions and responses from the View, and control the logic between other
    modules.
  
    The Controller is the 'Middle man'; eliminating logic from the views. This prevents complexity and further organizes
    your code. It is not a required module to use, however every component has one for you to use. The benefits of the
    controller can include preprocessing of information and set-up of Components with its modules prior and after
    rendering a View. A Component upon its initialization will call the init method of its Controller module.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Controller = (function(superClass) {
    extend(Controller, superClass);

    function Controller() {
      return Controller.__super__.constructor.apply(this, arguments);
    }


    /*
      By default, this does nothing during initialization unless it is overridden.
    
      Note: You can apply logic to the constructor of the Controller, but you will not have any access to the other
      modules of the Component until the Component has been initialized.
    
      @example Providing set-up to a Component through the Controller.
      
        // Register the Controller to the Component's path name with a Module loader, this will allow the Component to
        // find its relating modules.
        // Using a CommonJS set-up
        
        require.register('dummy/controller', function(exports, require, module) {
          var DummyComponentController;
          return module.exports = exports = DummyComponentController = (function() {
            function DummyComponentController() {}
    
            Tweak.extends(DummyComponentController, Tweak.Controller);
    
            DummyComponentController.prototype.init = function() {
              // By passing true to to @model.set the model quietly updates
              return this.model.set('topping', this.component.config.topping, true);
            };
    
            return DummyComponentController;
    
          })();
        });
     */

    Controller.prototype.init = function() {};

    return Controller;

  })(Tweak.Events);


  /*
    A Collection is an extension to the Model Class. The main difference being that there the base to the attributes is an
    Array for a Collection. As Collections' base type is an Array there is extra methods available such as; push, splice,
    slice and many more. The collection can take advantage of all the Model based methods like setters and getters. Please
    see the Model class for more information on the methods inherited to the Collection.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Collection = (function(superClass) {
    var __fullTrigger;

    extend(Collection, superClass);

    function Collection() {
      return Collection.__super__.constructor.apply(this, arguments);
    }

    Collection.prototype.__base = function() {
      return [];
    };


    /*
      Method to trigger a change event for all of the properties in the Collection
     */

    __fullTrigger = function(ctx) {
      var item, key, ref;
      ref = ctx.attributes;
      for (key in ref) {
        item = ref[key];
        ctx.triggerEvent("changed:" + key, item);
      }
      return ctx.triggerEvent('changed', ctx.attributes);
    };


    /*
      Add a new property to the end of the Collection.
      @param [*] data Data to add to the end of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @param [Array<*>] params Additional parameters in an Array to pass to setter.
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.add = function() {
      var args;
      args = Array.prototype.slice.call(arguments);
      args.unshift(this.length);
      return this.set.apply(this, args);
    };


    /*
      Get an element at specified index.
      @param [Number] index Index of property to return.
      @param [Array<*>] params Additional parameters in an Array to pass to getter.
      @return [*] Returned data from the specified index.
     */

    Collection.prototype.at = function() {
      return this.get.apply(this, arguments);
    };


    /*
      Push a new property to the end of the Collection.
      @param [*] data Data to add to the end of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @param [Array<*>] params Additional parameters in an Array to pass to setter.
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.push = function() {
      return this.add.apply(this, arguments);
    };


    /*
      Splice method that allows for event triggering on the base object.
      @param [Number] position The position to insert the property at into the Collection.
      @param [Number] remove The amount of properties to remove from the Collection.
      @param [Array<*>] data an array of data to insert into the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @param [Array<*>] params Additional parameters in an Array to pass to setter.
      @return [Number] The length of the Collection.
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
      @example Removing four properties from the 6th position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.splice(5, 4);
    
      @example Inserting two properties from the 3rd position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.splice(2, 0, ['100', '200']);
    
      @example Silently insert two properties from the 3rd position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.splice(2, 0, ['100', '200'], true);
     */

    Collection.prototype.splice = function(position, remove, data, silent, params) {
      var attr, j, key, pos, ref, results1;
      if (data == null) {
        data = [];
      }
      if (silent == null) {
        silent = false;
      }
      if (params == null) {
        params = [];
      }
      if (remove > 0) {
        this.remove((function() {
          results1 = [];
          for (var j = position, ref = position + remove - 1; position <= ref ? j <= ref : j >= ref; position <= ref ? j++ : j--){ results1.push(j); }
          return results1;
        }).apply(this), true);
      }
      if (silent instanceof Array) {
        params = silent;
        silent = params != null ? params : false;
      }
      if (!(data instanceof Array)) {
        data = [data];
      }
      for (key in data) {
        attr = data[key];
        this.length++;
        pos = Number(key) + position;
        this.attributes.splice(pos, 0, 0);
        this.set(pos, attr, true, params[key]);
      }
      if (!silent) {
        __fullTrigger(this);
      }
      return this.length;
    };


    /*
      Insert values into base data at a given index (Short cut to splice method).
      @param [Number] index The index to insert the property at into the Collection.
      @param [Array<*>] data an array of data to insert into the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @param [Array<*>] params Additional parameters in an Array to pass to setter.
      @return [Number] The length of the Collection.
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
      @example Inserting two properties from the 3rd position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.insert(2, ['100', '200']);
    
      @example Silently insert two properties from the 3rd position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.splice(2, ['100', '200'], true);
     */

    Collection.prototype.insert = function(index, data, silent, params) {
      return this.splice.call(this, index, 0, data, silent, params);
    };


    /*
      Adds property to the first index of the Collection.
      @param [Array<*>] data an array of data to insert at the first index of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @param [Array<*>] params Additional parameters in an Array to pass to setter.
      @return [Number] The length of the Collection.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.unshift = function(data, silent, params) {
      return this.splice.call(this, 0, 0, data, silent, params);
    };


    /*
      Remove a property at the last index of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @return [*] The property value that was popped.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
      @example Remove the last property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.pop();
    
      @example Silently remove the last property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.pop(true);
     */

    Collection.prototype.pop = function(silent) {
      var length, result;
      length = this.length - 1;
      result = this.attributes[length];
      this.remove(length, silent);
      return result;
    };


    /*
      Remove a property at the first index of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @return [*] The property value that was shifted.
      
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
      @example Remove the first property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.shift();
    
      @example Silently remove the first property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.shift(true);
     */

    Collection.prototype.shift = function(silent) {
      var result;
      result = this.attributes[0];
      this.remove(0, silent);
      return result;
    };


    /*
      Reduce the collection by removing properties from the first index.
      @param [Number] length The length of the Array to shorten to.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @return [Number] The length of the Collection.
      
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
      @example Remove the first five properties from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.reduce(5);
    
      @example Silently remove the first five property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.reduce(5, true);
     */

    Collection.prototype.reduce = function(length, silent) {
      return this.splice.call(this, 0, length, [], silent);
    };


    /*
      Reduce the collection by removing properties from the last index.
      @param [Number] length The length of the Array to shorten to.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      @return [Number] The length of the Collection.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
      @example Remove the first five properties from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.reduce(5);
    
      @example Silently remove the first five property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.reduce(5, true);
     */

    Collection.prototype.reduceRight = function(length, silent) {
      return this.splice.call(this, this.length - length, length, [], silent);
    };


    /*
      Concatenate Arrays to the end of the Collection.
      @param [Array] array An Array to concatenate to the end of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes to the data.
      @param [Array<*>] params Additional parameters in an Array to pass to setter.
      @return [Number] The length of the Collection.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
      @example Concatenate an Array to the end of a collection.
        var collection;
        collection = new tweak.Collection();
        collection.concat([1,4,6]);
    
      @example Silently concatenate a set of Arrays to the end of a collection.
        var collection;
        collection = new tweak.Collection();
        collection.concat([1,4,6], true);
     */

    Collection.prototype.concat = function(array, silent, params) {
      return this.splice.call(this, this.length, 0, array, silent, params);
    };


    /*
      This method directly accesses the Collection's attributes's every method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
     */

    Collection.prototype.every = function() {
      var ref;
      return (ref = this.attributes).every.apply(ref, Array.prototype.slice.call(arguments));
    };


    /*
      This method directly accesses the Collection's attributes's filter method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
     */

    Collection.prototype.filter = function() {
      var ref;
      return (ref = this.attributes).filter.apply(ref, Array.prototype.slice.call(arguments));
    };


    /*
      This method directly accesses the Collection's attributes's forEach method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
     */

    Collection.prototype.forEach = function() {
      var ref;
      return (ref = this.attributes).forEach.apply(ref, Array.prototype.slice.call(arguments));
    };


    /*
      This method directly accesses the Collection's attributes's indexOf method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
     */

    Collection.prototype.indexOf = function(val, from) {
      return this.attributes.indexOf(val, from);
    };


    /*
      This method directly accesses the Collection's attributes's join method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join
     */

    Collection.prototype.join = function() {
      var ref;
      return (ref = this.attributes).join.apply(ref, Array.prototype.slice.call(arguments));
    };


    /*
      This method directly accesses the Collection's attributes's lastIndexOf method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf
     */

    Collection.prototype.lastIndexOf = function(val, from) {
      if (from == null) {
        from = this.attributes.length - 1;
      }
      return this.attributes.lastIndexOf(val, from);
    };


    /*
      This method directly accesses the Collection's attributes's map method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
     */

    Collection.prototype.map = function() {
      var ref;
      return (ref = this.attributes).map.apply(ref, Array.prototype.slice.call(arguments));
    };


    /*
      This method directly accesses the Collection's attributes's reverse method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse
    
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.reverse = function(silent) {
      var result;
      result = this.attributes.reverse();
      if (!silent) {
        __fullTrigger(this);
      }
      return result;
    };


    /*
      This method directly accesses the Collection's attributes's slice method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
     */

    Collection.prototype.slice = function(begin, end) {
      return this.attributes.slice(begin, end);
    };


    /*
      This method directly accesses the Collection's attributes's some method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
     */

    Collection.prototype.some = function() {
      var ref;
      return (ref = this.attributes).some.apply(ref, Array.prototype.slice.call(arguments));
    };


    /*
      This method directly accesses the Collection's attributes's sort method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    
      @param [Function] fn (optional) If a comparing function is present then this is passed to sort function.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.sort = function(fn, silent) {
      var ref, result;
      if (typeof fn === 'boolean') {
        ref = [fn, silent], silent = ref[0], fn = ref[1];
      }
      result = fn != null ? this.attributes.sort(fn) : this.attributes.sort();
      if (!silent) {
        __fullTrigger(this);
      }
      return result;
    };

    return Collection;

  })(Tweak.Model);


  /*
    The future of MVC doesn't always lie in web applications; the architecture to
    TweakJS allows for integration of components anywhere on a website. For example
    you can plug "Web Components" into your static site; like sliders, accordions.
    The flexibility is endless; allowing MVC to be used from small web components
    to full scale one page web applications.
  
    TweakJS wraps its Models, Views, Templates, and Controllers into a Component
    module. The Component module acts intelligently to build up your application
    with simple configuration files. Each Component its built through a config
    object; this allows for powerful configuration with tonnes of flexibility.
    The config objects are extremely handy for making Components reusable, with
    easy accessible configuration settings.
  
    Each Component can have sub Components which are accessible in both directions;
    although it is recommended to keep functionality separate it sometimes comes in
    handy to have access to other parts of the application. Each Component can
    extend another Component, which will then inherent the models, views, templates,
    and controllers directly from that Component. If you however want to extend a
    Component using a different Model you can simply overwrite that model, or extend
    the functionality to the inherited model Components model.
  
    Examples are not exact, and will not directly represent valid code; the aim of
    an example is to be a rough guide. JS is chosen as the default language to
    represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language.
    Support can be found through the community if needed. Please see our
    Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Component = (function() {
    var __addModule, __buildConfig, __render;

    Component.prototype.model = null;

    Component.prototype.view = null;

    Component.prototype.components = null;

    Component.prototype.controller = null;

    Component.prototype.router = null;

    Component.prototype.modules = ['router', 'components', 'collection', 'model', 'controller', 'view'];


    /*
      Set the component up along with its default modules.
    
      @param [Object] relation Relation to the Component.
      @param [Object] options Configuration for the Component.
     */

    function Component(relation, options) {
      var j, k, len, len1, name, name2, prop, prop2, ref, ref1;
      if (options == null) {
        throw new Error('No options given');
      }
      relation = this.relation = relation === window ? {} : relation;
      if (relation.relation == null) {
        relation.relation = {};
      }
      this.parent = relation instanceof Tweak.Component ? relation : relation.component || relation;
      this.root = this.parent.root || this;
      this.name = options.name;
      if (this.name == null) {
        throw new Error('No name given');
      }
      options.name = this.name = Tweak.toAbsolute(this.parent.name || '', this.name);
      this.config = __buildConfig.call(this, options);
      if (this.config.router) {
        __addModule.call(this, 'router', Tweak.Router);
      }
      if (this.config.collection) {
        __addModule.call(this, 'collection', Tweak.Collection);
      }
      __addModule.call(this, 'model', Tweak.Model);
      __addModule.call(this, 'view', Tweak.View);
      __addModule.call(this, 'controller', Tweak.Controller);
      __addModule.call(this, 'components', Tweak.Components);
      ref = this.modules;
      for (j = 0, len = ref.length; j < len; j++) {
        name = ref[j];
        if (!(prop = this[name])) {
          continue;
        }
        prop.parent = this.parent;
        prop.component = this;
        ref1 = this.modules;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          name2 = ref1[k];
          if (name !== name2 && (prop2 = this[name2])) {
            prop[name2] = prop2;
          }
        }
      }
    }


    /*
      When the component is initialised it's modules are also initialised.
     */

    Component.prototype.init = function() {
      var item, j, len, name, ref;
      ref = this.modules;
      for (j = 0, len = ref.length; j < len; j++) {
        name = ref[j];
        if (item = this[name]) {
          if (typeof item.init === "function") {
            item.init();
          }
        }
      }
    };


    /*
      Builds the configuration object for the Component.
      @param [Object] options Component options.
      @return [Object] Combined config based on the components inheritance.
     */

    __buildConfig = function(options) {
      var _path, configs, extension, i, j, name, paths, ref, ref1, requested, result;
      configs = [Tweak.clone(options)];
      paths = this.paths = [this.name];
      extension = options["extends"] || this.name;
      name = ((ref = this.parent) != null ? ref.name : void 0) || this.name;
      while (extension) {
        requested = Tweak.request(name, extension + "/config", Tweak.strict ? null : {});
        _path = Tweak.toAbsolute(name, extension);
        if (paths.indexOf(_path) === -1) {
          paths.push(_path);
        }
        configs.push(Tweak.clone(requested));
        extension = requested["extends"];
      }
      result = configs[configs.length - 1];
      for (i = j = ref1 = configs.length - 1; ref1 <= 0 ? j <= 0 : j >= 0; i = ref1 <= 0 ? ++j : --j) {
        result = Tweak.combine(result, configs[i]);
      }
      if (result.model == null) {
        result.model = {};
      }
      if (result.view == null) {
        result.view = {};
      }
      if (result.controller == null) {
        result.controller = {};
      }
      if (result.components == null) {
        result.components = [];
      }
      return result;
    };


    /*
      Add a module to the Component, if module can't be found then it will use a surrogate object.
      @param [String] name Name of the module.
      @param [Object] surrogate Surrogate if the module can not be found.
     */

    __addModule = function(name, surrogate) {
      var Module, module;
      Module = Tweak.request(this.paths, "./" + name, surrogate);
      module = this[name] = new Module(this.config[name]);
      module.component = this;
      module.root = this.root;
      if (typeof module.__constructor === "function") {
        module.__constructor();
      }
    };


    /*
      Reusable method to render and re-render.
      @param [String] type The type of rendering to do either 'render' or 'rerender'.
     */

    __render = function(type) {
      this.view.addEvent(type + "ed", function() {
        this.components.addEvent('ready', function() {
          return this.controller.triggerEvent('ready');
        }, this, 1);
        return this.components[type]();
      }, this, 1);
      this.view[type]();
    };


    /*
      Renders itself and its subcomponents.
      @event ready Triggers ready event when itself and its Components are ready/rendered.
     */

    Component.prototype.render = function() {
      __render.call(this, 'render');
    };


    /*
      Re-renders itself and its subcomponents.
      @event ready Triggers ready event when itself and its Components are ready/re-rendered.
     */

    Component.prototype.rerender = function() {
      __render.call(this, 'rerender');
    };


    /*
      Destroy this Component. It will clear the view if it exists; and removes it from the Components Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
     */

    Component.prototype.destroy = function(silent) {
      var components, item, key, ref;
      this.view.clear();
      components = this.relation.components;
      if (components != null) {
        ref = components.data;
        for (key in ref) {
          item = ref[key];
          if (item === this) {
            components.remove(key, silent);
          }
        }
      }
    };


    /*
      Short-cut to the controllers findEvent method.
    
      @overload findEvent(names, build)
        Find events on controller with a space separated string.
        @param [String] names The event name(s); split on a space.
        @param [Boolean] build (default = false) Whether to add an event object to the controller when none can be found.
        @return [Array<Event>] All event objects that are found/created then it is returned in an Array.
    
      @overload findEvent(names, build)
        Find events on controller with an array of names (strings).
        @param [Array<String>] names An array of names (strings).
        @param [Boolean] build (default = false) Whether to add an event object to the controller when none can be found.
        @return [Array<Event>] All the controllers event objects that are found/created then it is returned in an Array.
     */

    Component.prototype.findEvent = function(names, build) {
      return this.controller.findEvent(names, build);
    };


    /*
      Short-cut to the controllers addEvent method.
    
      @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
      @param [Function] callback The event callback function.
      @param [Number] maximum (default = null) The maximum calls on the event listener. After the total calls the events
      callback will not invoke.
      @param [Object] context The contextual object of which the event to be bound to.
     */

    Component.prototype.addEvent = function(names, callback, max, context) {
      return this.controller.addEvent(names, callback, max, context);
    };


    /*
      Short cut to the controllers removeEvent method.
    
      @param [String] names The event name(s). Split on a space, or an array of event names.
      @param [Function] callback (optional) The callback function of the event. If no specific callbacki s given then all
      the controller events under event name are removed.
      @param [Object] context (default = this) The contextual object of which the event is bound to. If this matches then
      it will be removed, however if set to null then all events no matter of context will be removed.
     */

    Component.prototype.removeEvent = function(names, callback, context) {
      return this.controller.removeEvent(names, callback, context);
    };


    /*
      Short cut to the controllers triggerEvent method.
    
      @overload triggerEvent(names, params)
        Trigger events on controller by name only.
        @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @param [...] params Parameters to pass into the callback function.
    
      @overload triggerEvent(options, params)
        Trigger events on controller by name and context.
        @param [Object] options Options and limiters to check against callbacks.
        @param [...] params Parameters to pass into the callback function.
        @option options [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @option options [Context] context (default = null) The context of the callback to check against a callback.
     */

    Component.prototype.triggerEvent = function() {
      var names, params, ref;
      names = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return (ref = this.controller).triggerEvent.apply(ref, [names].concat(slice.call(params)));
    };


    /*
      Shortcut to the controllers updateEvent method.
    
      @param [String] names The event name(s). Split on a space, or an array of event names.
      @param [Object] options Optional limiters and update values.
      @option options [Object] context The contextual object to limit updating events to.
      @option options [Function] callback Callback function to limit updating events to.
      @option options [Number] max Set a new maximum calls to an event.
      @option options [Number] calls Set the amount of calls that has been triggered on this event.
      @option options [Boolean] reset (default = false) If true then calls on an event get set back to 0.
      @option options [Boolean] listen Whether to enable or disable listening to event.
     */

    Component.prototype.updateEvent = function(names, options) {
      return this.controller.updateEvent(names, options);
    };


    /*
      Resets the controllers events to empty.
     */

    Component.prototype.resetEvents = function() {
      return this.controller.resetEvents();
    };


    /*
      This method is used to extract all data of a component. If there is an export method within the Component Controller
      then the Controller export method will be executed with the data returned from the method.
      @param [Object] limit Limit the data from model to be exported
      @return [Object] Extracted data from Component.
     */

    Component.prototype["export"] = function(limit) {
      var base;
      return (typeof (base = this.controller)["export"] === "function" ? base["export"]() : void 0) || {
        model: this.model["export"](limit),
        components: this.components["export"]()
      };
    };


    /*
      This method is used to import data into a component. If there is an import method within the Component Controller
      then the Controller import method will be executed with the data passed to the method.
      @param [Object] data Data to import to the Component.
      @option data [Object] model Object to import into the Component's Model.
      @option data [Array<Object>] components Array of Objects to import into the Component's Components.
     */

    Component.prototype["import"] = function(data) {
      if (this.controller["import"] != null) {
        return this.controller["import"](data);
      } else {
        if (data.model) {
          this.model["import"](data.model);
        }
        if (data.components) {
          return this.components["import"](data.components);
        }
      }
    };

    return Component;

  })();


  /*
    This class provides a collection of components. Upon initialisation components
    are dynamically built, from its configuration. The configuration for this
    component is an Array of component names (Strings). The component names are
    then used to create a component. Components nested within those components are
    then initialised creating a powerful scope of nest components that are completely
    unique to themselves.
  
    Examples are not exact, and will not directly represent valid code; the aim of
    an example is to be a rough guide. JS is chosen as the default language to
    represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language.
    Support can be found through the community if needed. Please see our
    Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Components = (function(superClass) {
    var __render;

    extend(Components, superClass);

    function Components() {
      return Components.__super__.constructor.apply(this, arguments);
    }


    /*
      Construct the Components module based on the information already in its attributes. The __constructor method is
      called before initialization of its components - to ensure all components are accessible at the time of
      initialization.
     */

    Components.prototype.__constructor = function() {
      var _absolute, _componentName, _extends, _paths, attributes, component, i, item, j, k, l, len, len1, len2, len3, len4, m, n, name, ref, ref1, ref2, ref3, results1;
      _componentName = this.component.name;
      _absolute = function(path) {
        return Tweak.toAbsolute(_componentName, path);
      };
      _paths = function(paths) {
        var j, len, path, ref, results1;
        ref = Tweak.splitPaths(paths);
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          path = ref[j];
          results1.push(_absolute(path));
        }
        return results1;
      };
      attributes = [];
      ref = this.attributes;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        if (item instanceof Array) {
          _extends = _absolute(item[1]);
          ref1 = _paths(item[0]);
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            name = ref1[k];
            attributes.push(new Tweak.Component(this, {
              name: name,
              "extends": _extends
            }));
          }
        } else if (typeof item === 'string') {
          ref2 = _paths(item);
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            name = ref2[l];
            attributes.push(new Tweak.Component(this, {
              name: name
            }));
          }
        } else if (!(item instanceof Tweak.Component)) {
          item["extends"] = _absolute(item["extends"]);
          ref3 = _paths(item.name);
          for (m = 0, len3 = ref3.length; m < len3; m++) {
            name = ref3[m];
            item.name = name;
            attributes.push(new Tweak.Component(this, item));
          }
        }
      }
      results1 = [];
      for (i = n = 0, len4 = attributes.length; n < len4; i = ++n) {
        component = attributes[i];
        results1.push(this.set(i, component));
      }
      return results1;
    };


    /*
      Construct the Components derived collection with given options from the Components configuration.
     */

    Components.prototype.init = function() {
      var component, j, len, ref;
      ref = this.attributes;
      for (j = 0, len = ref.length; j < len; j++) {
        component = ref[j];
        component.init();
      }
    };


    /*
      @private
      Reusable method to render and re-render.
      @param [String] type The type of rendering to do either 'render' or 'rerender'.
     */

    __render = function(type) {
      var _item, item, j, len, ref;
      if (this.length === 0) {
        this.triggerEvent('ready');
      } else {
        this.total = 0;
        ref = this.attributes;
        for (j = 0, len = ref.length; j < len; j++) {
          item = ref[j];
          _item = item;
          item.controller.addEvent('ready', function() {
            if (++this.total === this.length) {
              return this.triggerEvent('ready');
            }
          }, this, 1);
          _item[type]();
        }
      }
    };


    /*
      Renders all of its Components.
      @event ready Triggers ready event when itself and its sub-Components are ready/rendered.
     */

    Components.prototype.render = function() {
      __render.call(this, 'render');
    };


    /*
      Re-render all of its Components.
      @event ready Triggers ready event when itself and its sub-Components are ready/re-rendered.
     */

    Components.prototype.rerender = function() {
      __render.call(this, 'rerender');
    };


    /*
      Find Component with matching data in model.
      @param [String] property The property to find matching value against.
      @param [*] value Data to compare to.
      @return [Array] An array of matching Components.
     */

    Components.prototype.whereData = function(property, value) {
      var collectionKey, componentData, data, key, modelData, prop, result;
      result = [];
      componentData = this.attributes;
      for (collectionKey in componentData) {
        data = componentData[collectionKey];
        modelData = data.model.data || model.data;
        for (key in modelData) {
          prop = modelData[key];
          if (key === property && prop === value) {
            result.push(data);
          }
        }
      }
      return result;
    };


    /*
      Reset this Collection of components. Also destroys it's components (views removed from DOM).
      @event changed Triggers a generic event that the store has been updated.
     */

    Components.prototype.reset = function() {
      var item, j, len, ref;
      ref = this.attributes;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        item.destroy();
      }
      Components.__super__.reset.call(this);
    };

    return Components;

  })(Tweak.Collection);


  /*
    Simple cross browser history API. Upon changes to the history a change event is called. The ability to hook event
    listeners to the tweak.History API allows routes to be added accordingly, and for multiple Routers to be declared for
    better code structure.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.History = (function(superClass) {
    var __getHash, __getPath, __getSearch, __getURL, __interval, __setHash, __toggleListeners, history, iframe, intervalRate, location, root, started, url, useHash, usePush, win;

    extend(History, superClass);

    function History() {
      this.changed = bind(this.changed, this);
      return History.__super__.constructor.apply(this, arguments);
    }

    usePush = true;

    useHash = false;

    __interval = null;

    intervalRate = 50;

    started = false;

    root = '/';

    iframe = null;

    url = null;

    location = null;

    history = null;

    win = null;


    /*
      Get the URL formatted without the hash.
      @param [Window] _win The window to retrieve hash.
      @return Normalized URL without hash.
     */

    __getHash = function(_win) {
      var match;
      if (_win == null) {
        _win = win;
      }
      match = _win.location.href.match(/#(.*)$/);
      if (match) {
        return match[1];
      } else {
        return '';
      }
    };


    /*
      Get search part of url
      @return search if it matches or return empty string.
     */

    __getSearch = function() {
      var match;
      match = location.href.replace(/#.*/, '').match(/\?.+/);
      if (match) {
        return match[0];
      } else {
        return '';
      }
    };


    /*
      Get the pathname and search parameters, without the root.
      @return Normalized URL.
     */

    __getPath = function() {
      var _root, path;
      path = decodeURI("" + location.pathname + (__getSearch()));
      _root = root.slice(0, -1);
      if (!path.indexOf(_root)) {
        path = path.slice(_root.length);
      }
      if (path.charAt(0) === '/') {
        return path.slice(1);
      } else {
        return path;
      }
    };


    /*
      Get a normalized URL.
      @param [String] URL The URL to normalize - if null then URL will be retrieved from window.location.
      @param [Boolean] force Force the returning value to be hash state.
      @return Normalized URL without trailing slashes at either side.
     */

    __getURL = function(_url, force) {
      var _root;
      if (_url == null) {
        if (usePush || force) {
          _url = decodeURI("" + location.pathname + location.search);
          _root = root.replace(/\/$/, '');
          if (!_url.indexOf(_root)) {
            _url = _url.slice(_root.length);
          }
        } else {
          _url = __getHash();
        }
      }
      _url = _url.replace(/^\/{2,}/g, '/');
      if (!_url.match(/^\/+/)) {
        _url = "/" + _url;
      }
      return _url.replace(/\/+$/g, '');
    };


    /*
      Change the hash or replace the hash.
      @param [Location] _win The window object to use to set location.
      @param [String] URL The URL to replace the current hash with.
      @param [Boolean] replace Whether to replace the hash by href or to change hash directly.
     */

    __setHash = function(_win, url, replace) {
      if (iframe === _win) {
        _win.document.open().close();
      }
      if (replace) {
        _win.location.replace((location.href.replace(/(javascript:|#).*$/, '')) + "#" + url);
      } else {
        _win.location.hash = "" + url;
      }
    };


    /*
      Add listeners of remove history change listeners.
      @param [String] prefix (Default = 'on') Set the prefix - 'on' or 'off'.
     */

    __toggleListeners = function(prefix) {
      if (prefix == null) {
        prefix = 'on';
      }
      if (usePush) {
        Tweak.$(win)[prefix]('popstate', this.changed);
      } else if (useHash) {
        if (!iframe) {
          Tweak.$(win)[prefix]('hashchange', this.changed);
        } else if (prefix === 'on') {
          __interval = setInterval(this.changed, intervalRate);
        } else {
          clearInterval(__interval);
          document.body.removeChild(iframe.frameElement);
          iframe = __interval = null;
        }
      }
    };


    /*
      Start listening to the URL changes to push back the history API if available.
      
      @param [Object] options An optional object to pass in optional arguments.
      @option options [Boolean] useHash (default = false) Specify whether to use hashState if true then pushState will be set to false.
      @option options [Boolean] forceRefresh (default = false) When set to true then pushState and hashState will not be used.
      @option options [Number] interval (default = null) When set to a number this is what the refresh rate will be when an interval has to be used to check changes to the URL.
      @option options [Boolean] silent (default = false) If set to true then an initial change event trigger will not be called.
      @option options [Window Object] window (default = window) Set the window object.
      @option options [Location Object] location (default = window.location) Set the location object.
      @option options [History Object] history (default = window.history) Set the history object.
      
      @event changed When the URL is updated a change event is fired from tweak.History.
    
      @example Starting the history with auto configuration.
        tweak.History.start();
    
      @example Starting the history with forced HashState.
        tweak.History.start({
          hashState:true
        });
    
      @example Starting the history with forced PushState.
        tweak.History.start({
          pushState:true
        });
    
      @example Starting the history with forced refresh or page.
        tweak.History.start({
          forceRefresh:true
        });
    
      @example Starting the history with an interval rate for the polling speed for older browsers.
        tweak.History.start({
          hashState:true,
          interval: 100
        });
    
      @example Starting the history silently.
        tweak.History.start({
          hashState:true,
          silent: true
        });
     */

    History.prototype.start = function(options) {
      var body, frame;
      if (options == null) {
        options = {};
      }
      if (started) {
        return;
      }
      started = true;
      win = options.window || window;
      location = options.location || win.location;
      history = options.history || win.history;
      usePush = options.useHash ? false : history != null ? history.pushState : void 0;
      useHash = !usePush;
      if (options.forceRefresh || (useHash && !('onhashchange' in win))) {
        useHash = usePush = false;
      }
      intervalRate = options.interval || intervalRate;
      root = ("/" + (options.root || '/') + "/").replace(/^\/+|\/+$/g, '/');
      url = __getURL();
      if (useHash) {
        location.replace(root + "#" + (__getPath()) + (__getHash()));
      } else if (usePush && __getHash() !== '') {
        this.set(__getHash(), {
          replace: true
        });
      }
      if (!usePush && !useHash && !options.forceRefresh) {
        frame = document.createElement('iframe');
        frame.src = 'javascript:0';
        frame.style.display = 'none';
        frame.tabIndex = -1;
        body = document.body;
        iframe = body.insertBefore(frame, body.firstChild).contentWindow;
        __setHash(iframe, "#" + url, false);
      }
      __toggleListeners.call(this);
      if (!options.silent) {
        return this.triggerEvent('changed', url.replace(/^\/+/, ''));
      }
    };


    /*
     Stop tweak.History. Most likely useful for a web component that uses the history to change state,
     but if removed from page then component may want to stop the history.
     */

    History.prototype.stop = function() {
      __toggleListeners.call(this, 'off');
      return started = false;
    };


    /*
      Update the history while also updating the URL.
      
      @param [Object] options An optional object to pass in optional arguments.
      @option options [Boolean] replace (default = false) Specify whether to replace the current item in the history.
      @option options [Boolean] silent (default = true) Specify whether to allow triggering of event when setting the URL.
    
      @example Setting the History (updating the URL).
        tweak.History.set('/#/fake/url');
    
      @example Replacing the last History state (updating the URL).
        tweak.History.set('/#/fake/url', {
          replace:true
        });
    
      @example Setting the History (updating the URL) and calling history change event.
        tweak.History.set('/#/fake/url', {
          silent:false
        });
     */

    History.prototype.set = function(_url, options) {
      var _root, fullUrl, replace;
      if (options == null) {
        options = {};
      }
      if (!started) {
        return;
      }
      if (options.silent == null) {
        options.silent = true;
      }
      replace = options.replace;
      _url = __getURL(_url) || '';
      _root = root;
      if (_url === '' || _url.charAt(0) === '?') {
        _root = _root.slice(0, -1) || '/';
      }
      fullUrl = "" + _root + (_url.replace(/^\/*/, ''));
      _url = decodeURI(_url.replace(/#.*$/, ''));
      if (url === _url) {
        return;
      }
      url = _url;
      if (usePush) {
        history[replace ? 'replaceState' : 'pushState']({}, document.title, fullUrl);
      } else if (useHash) {
        __setHash(win, _url, replace);
        if (iframe && _url !== __getHash(iframe)) {
          __setHash(iframe, _url, replace);
        }
      } else {
        location.assign(fullURL);
        return;
      }
      if (!options.silent) {
        this.triggerEvent('changed', (url = _url).replace(/^\/+/, ''));
      }
    };


    /*
      Check whether the URL has been changed. Triggerig change event when changes are detected
    
      @event changed Triggers 'changed' event when a change is detected in the History.
     */

    History.prototype.changed = function() {
      var now, old;
      now = __getURL();
      old = url;
      if (now === old) {
        if (iframe) {
          now = __getHash(iframe);
          this.set(now);
        } else {
          return false;
        }
      }
      this.triggerEvent('changed', url = now);
      return true;
    };

    return History;

  })(Tweak.Events);

  Tweak.History = new Tweak.History();


  /*
    Web applications often provide linkable, bookmark, shareable URLs for important locations in the application. The
    Router module provides methods for routing to events which can control the application. Traditionally it used to be
    that routers worked from hash fragments (#page/22). However, the HTML5 History API now provides standard URL formats
    (/page/22). Routers provide functionality that links applications/components/modules together through data passed
    through the URL.
  
    The router's routes can be formatted as a string that provides additional easy management to routing of events. Routes
    can implement splats, parameters and optional parameters. Routes can also be RegExp for more flexibility. When the
    history changes it will automatically compare routes and trigger events when matches are found; the triggered events
    will pass the data from the URL.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
    
    @example Route with parameters
      Adding a route ':section:page' or ':section/:page' attached to the event of 'navigation', will trigger a
      'navigation' event and pass the following data with a similar HashState of '/#/5/93'.
      {
        url:'/5/93',
        data:{
          section:'5',
          page:'93'
        }
      }
    
    @example Route with parameters one being optional
      Adding a optional parameter route ':section?page' or ':section/?page' attached to the event of 'navigation',
      will trigger a 'navigation' event and pass the following data with a similar HashState of '/#/5/6'.
      {
        url:'/5/6',
        data:{
          section:'5',
          page:'6'
        }
      }
  
      Adding a optional parameter route ':section?page' or ':section/?page' attached to the event of 'navigation',
      will trigger a 'navigation' event and pass the following data with a similar HashState of '/#/5'.
      {
        url:'/5',
        data:{
          section:'5'
        }
      }
    
    @example Route with splat
      Adding a splat route ':section:page/*' or ':section/:page/*' attached to the event of 'navigation', will
      trigger a 'navigation' event and pass the following data with a similar HashState of '/#/5/6/www.example.com'.
      {
        url:'/5/6/www.example.com',
        data:{
          section:'5',
          page:'6',
          splat:'www.example.com'
        }
      }
    
    @example URL with query string
      When you want to use URLs that contain a query string, '/blog?id=9836384&light&reply=false', then the data
      sent back to an event will look like:
      {
        url:'/blog?id=9836384&light&reply=false',
        data:{
          blog:{
            id:9836384,
            light:'true',
            reply:'false'
          }
        }
      }
   */

  Tweak.Router = (function(superClass) {
    var __changed, __escapeReg, __getKeys, __getQuery, __paramReg, __splatReg, __toRegex;

    extend(Router, superClass);


    /*
      The constructor initialises the router with default routes. It will also begin listening to Tweak.History.
      
      @param [object] routes (optional, default = {}) An object containing event name based keys to an Array of routes.
    
      @example Creating a Router with a set of predefined routes.
        var router;
        router = new tweak.Router({
          'navigation':[
            ':section/:page',
            /:website/:section/?page
          ],
          'demo':[
            ':splat/:example/*'
          ]
        });
     */

    function Router(routes1) {
      this.routes = routes1 != null ? routes1 : {};
      Tweak.History.addEvent('changed', __changed, this);
    }


    /*
      Add a route to an event.
      @param [String] event The event name.
      @param [String, Reg-ex] route A string or Reg-ex formatted string or Reg-ex.
    
      @example Adding a single string formatted route to an event.
        var router;
        router = new tweak.Router();
        router.add('navigation', '/:section/:page');
    
      @example Adding a single Reg-ex formatted route to an event.
        var router;
        router = new tweak.Router();
        router.add('navigation', /^(*.)$/);
     */

    Router.prototype.add = function(event, route) {
      if (this.routes[event] != null) {
        this.routes[event].push(route);
      } else {
        this.routes[event] = [route];
      }
    };


    /*
      @overload remove(event, route)
        Remove a single string formatted route from an event.
        @param [String] event The event name to add route to.
        @param [String] route A string formatted string. (':section/:page')
    
      @overload remove(event, route)
        Remove a string containing multiple string formatted routes from an event.
        @param [String] event The event name to add route to.
        @param [String] route A string containing multiple string formatted routes. (':section/:page :section/:page/*')
    
      @overload remove(event, route)
        Remove a single Reg-ex formatted route from an event.
        @param [String] event The event name to add route to.
        @param [Boolean] route A Reg-ex formatted route. (/^.*$/)
      
      @example Removing a single string formatted route from an event
        var router;
        router = new tweak.Router();
        router.remove('navigation', '/:section/:page');
    
      @example Removing a multiple string formatted routes from an event.
        var router;
        router = new tweak.Router();
        router.remove('navigation', '/:section/:page /:website/:section/?page');
    
      @example Removing a single Reg-ex formatted route from an event.
        var router;
        router = new tweak.Router();
        router.remove('navigation', /^(*.)$/);
     */

    Router.prototype.remove = function(event, routes) {
      var key, route, routers;
      routers = this.routes[event];
      if (typeof routes === 'string') {
        routes = (" " + (routes.replace(/\s+/g, ' ')) + " ").split(' ');
      }
      for (key in routers) {
        route = routers[key];
        if (route === routes) {
          delete routers[key];
        }
      }
      this.routes[event] = routers;
      if ((routers != null) && ((routes == null) || routers.length === 0)) {
        delete this.routes[event];
      }
    };


    /*
      Reg-ex to get parameters from a URL.
     */

    __paramReg = /\/?[?:]([^?\/:]*)/g;


    /*
      Reg-ex to escape characters for the returned Reg-ex
     */

    __escapeReg = /[\-\\\^\[\]\s{}+.,$|#]/g;


    /*
      Reg-ex to be able to retrieve the splat from end of URL
     */

    __splatReg = /\/?(\*)$/;


    /*
      Checks URL segment to see if it can extract additional data when formatted like a query string.
      @param [String] segment The URL segment to extract additional data when formatted as a query string.
      @return [Object, String] Extracted data of given segment parameter.
     */

    __getQuery = function(segment) {
      var j, len, option, params, props, query, result;
      if (query = /^.*\?(.+)/.exec(segment)) {
        if (params = /([^&]+)&*/.exec(query[1])) {
          result = {};
          for (j = 0, len = params.length; j < len; j++) {
            option = params[j];
            if (props = /(.+)[:=]+(.+)|(.+)/.exec(option)) {
              result[props[3] || props[1]] = props[2] || 'true';
            }
          }
        }
      } else if (segment) {
        result = segment.replace(/\?/g, '');
      }
      return result;
    };


    /*
      Converts a string formatted route into its Reg-ex counterpart.
      @param [String] route The route to convert into a Reg-ex formatted route.
      @return [Reg-ex] The Reg-ex formatted route of given string formatted route.
     */

    __toRegex = function(route) {
      route = route.replace(__escapeReg, '\\$&');
      route = route.replace(__paramReg, function(match) {
        var res;
        res = '\\/?([^\\/]*?)';
        if (/^\/?\?/.exec(match)) {
          return "(?:" + res + ")?";
        } else {
          return res;
        }
      });
      route = route.replace(__splatReg, '\\/?(.*?)');
      return new RegExp("^" + route + "[\\/\\s]?$");
    };


    /*
      Get the parameter keys from a string formatted route to use as the data passed to event.
      @param [String] route The string formatted route to get parameter keys from.
     */

    __getKeys = function(route) {
      var res;
      (res = route.match(__paramReg) || []).push('splat');
      return res;
    };


    /*
      When history event is made this method is called to check this Routers events to see if any route events can be triggered.
      @param [String] url A URL to check route events to.
      @event {event_name} Triggers a route event with data from URL.
     */

    __changed = function(url) {
      var event, item, j, k, key, keys, len, len1, match, ref, ref1, res, route, routes;
      url = url.replace(/^\/+|\/+$/g, '');
      ref = this.routes;
      for (event in ref) {
        routes = ref[event];
        for (j = 0, len = routes.length; j < len; j++) {
          route = routes[j];
          keys = [];
          if (typeof route === 'string') {
            keys = __getKeys(route);
            route = __toRegex(route);
          }
          if (match = route.exec(url)) {
            res = {
              url: url,
              data: {}
            };
            match.splice(0, 1);
            key = 0;
            for (k = 0, len1 = match.length; k < len1; k++) {
              item = match[k];
              res.data[((ref1 = keys[key]) != null ? ref1.replace(/^[?:\/]*/, '') : void 0) || key] = __getQuery(item);
              key++;
            }
            this.triggerEvent(event, res);
          }
        }
      }
    };

    return Router;

  })(Tweak.Events);

}).call(this);

//# sourceMappingURL=tweak.js.map
